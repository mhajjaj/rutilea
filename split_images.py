# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kerzjrxxRztZjV66oaWIsLruMJPxhD20
"""
import os

import numpy as np
import imageio.v2 as imageio
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

# Load the image using imageio
HOME = os.getcwd()

image_dir = os.path.join(HOME, 
                         'GearInspection-Dataset3', 'CategoryNG', 
                         'ClassAll', 'train', 'images')
image_path = os.path.join(HOME, image_dir,
                          'file_year_2023_month_03_day_31_12_12_37_NG_2_0.png')
original_image = imageio.imread(image_path)

# Display the original image
plt.imshow(original_image)
plt.axis('off')
plt.title("Original Image")
plt.show()

# Compute the vertical profile of the gray image
vertical_profile = np.mean(original_image, axis=1)

# Plot the vertical profile
plt.figure(figsize=(10, 6))
plt.plot(vertical_profile)
plt.title("Vertical Profile of the Image")
plt.xlabel("Row Index")
plt.ylabel("Average Intensity")
plt.grid(True)
plt.show()

# Ensure vertical_profile is a 1-D array
vertical_profile = np.mean(original_image, axis=1).flatten()

# Identify peaks with a height around 180 in the vertical profile
peaks_180, _ = find_peaks(vertical_profile, height=(175, 185), distance=50)

# Compute the distances between consecutive peaks around 180
peak_distances_180 = np.diff(peaks_180)

# Estimate the height of a repeating pattern based on new peaks
pattern_height_180 = int(np.median(peak_distances_180))

# Adjust the start and end positions to add some margin
margin = 10

# Extract all repeating patterns with added margin based on identified peaks around 180
patterns_180_margin = []

for start in peaks_180:
    adjusted_start = max(0, start - margin)
    adjusted_end = start + pattern_height_180 + margin
    if adjusted_end <= original_image.shape[0]:
        pattern = original_image[adjusted_start:adjusted_end, :]
        patterns_180_margin.append(pattern)

# # Display all extracted repeating patterns with added margin
# fig, axs = plt.subplots(1, len(patterns_180_margin), figsize=(15, 5))
# for i, pattern in enumerate(patterns_180_margin):
#     axs[i].imshow(pattern)
#     axs[i].axis('off')
#     axs[i].set_title(f"Pattern {i+1}")

# Check if there are patterns to display
if len(patterns_180_margin) > 0:
    # Create subplots only if there are patterns
    fig, axs = plt.subplots(1, len(patterns_180_margin), figsize=(15, 5))
    
    # Loop through and display the patterns
    for i, pattern in enumerate(patterns_180_margin):
        axs[i].imshow(pattern)
        axs[i].axis('off')
        axs[i].set_title(f"Pattern {i+1}")
    
    plt.tight_layout()
    plt.show()
else:
    # Handle the case where there are no patterns to display
    print("No patterns found to display.")

plt.tight_layout()
plt.show()